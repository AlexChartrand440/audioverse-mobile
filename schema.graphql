# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------ 
type Aggregate {
  count: Int!
}

type Attachment implements Node {
  filename: String!

  """In bytes"""
  filesize: String!
  id: ID!
  mimeType: String!
  recording: Recording!
  url: URL!
}

type AudioFile implements Node {
  bitrate: Int!
  duration: Float!
  filename: String!

  """In bytes"""
  filesize: String!
  id: ID!
  mimeType: String!
  recording: Recording!
  url: URL!
}

type AuthenticatedUser {
  sessionToken: String!
  user: User!
}

type AuthenticatedUserPayload {
  authenticatedUser: AuthenticatedUser
  errors: [InputValidationError!]!
}

type Bible implements Node {
  book(id: ID!): BibleBook!
  books: [BibleBook!]!
  id: ID!
  isDramatized: Boolean!
  title: String!
}

type BibleBook implements Node {
  chapter(id: ID!): BibleChapter!
  chapterCount: Int!
  chapters: [BibleChapter!]!
  id: ID!
  isDramatized: Boolean!
  title: String!
}

type BibleChapter implements Node {
  id: ID!
  text: String!
  title: String!
  url: URL!
}

type BibleConnection {
  aggregate: Aggregate
  edges: [BibleEdge!]
  nodes: [Bible!]
  pageInfo: PageInfo!
}

type BibleEdge {
  cursor: String!
  node: Bible!
}

type BlogPost implements Node {
  body: String!
  id: ID!
  image: Image
  title: String!
}

type BlogPostConnection {
  aggregate: Aggregate
  edges: [BlogPostEdge!]
  nodes: [BlogPost!]
  pageInfo: PageInfo!
}

type BlogPostEdge {
  cursor: String!
  node: BlogPost!
}

input BlogPostOrder {
  direction: OrderByDirection!
  field: BlogPostSortableField!
}

"""Properties by which blog post connections can be ordered."""
enum BlogPostSortableField {
  PUBLISHED_AT
}

type Collection implements Node {
  """The canonical HTML path to this resource."""
  canonicalPath: String!

  """The canonical URL to this resource."""
  canonicalUrl: String!
  contentType: CollectionContentType!
  description: String!
  endDate: Date
  id: ID!
  image: Image
  imageWithFallback: Image!
  isHidden: Boolean
  location: String
  logoImage: Image @deprecated(reason: "Collection.logoImage is replaced with Collection.image")
  logoImageWithFallback: Image! @deprecated(reason: "Collection.logoImageWithFallback is replaced with Collection.imageWithFallback")
  notes: String
  recordings(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [RecordingsOrder!]
    presenterId: ID
    sequenceId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!
  sequences(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished sequences. Requires catalog role."""
    includeUnpublished: Boolean

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [SequenceOrder!]
    search: String
    sponsorId: ID
  ): SequenceConnection!

  """A shareable short URL to this resource."""
  shareUrl: String!
  sponsor: Sponsor
  startDate: Date
  summary: String!
  title: String!
}

type CollectionConnection {
  aggregate: Aggregate
  edges: [CollectionEdge!]
  nodes: [Collection!]
  pageInfo: PageInfo!
}

"""The available types of collections."""
enum CollectionContentType {
  AUDIOBOOK_SERIES
  CONFERENCE
  STORY_PROGRAM
}

input CollectionCreateInput {
  contentType: CollectionContentType!
  description: String
  isHidden: Boolean
  location: String
  notes: String
  sponsorId: ID!
  summary: String
  title: String!
}

type CollectionEdge {
  cursor: String!
  node: Collection!
}

type CollectionPayload {
  collection: Collection
  errors: [InputValidationError!]!
}

input CollectionsOrder {
  direction: OrderByDirection!
  field: CollectionsSortableField!
}

"""Properties by which collection connections can be ordered."""
enum CollectionsSortableField {
  CREATED_AT
  ID
  TITLE
}

input CollectionUpdateInput {
  description: String
  isHidden: Boolean
  location: String
  notes: String
  sponsorId: ID
  summary: String
  title: String
}

"""Date custom scalar type"""
scalar Date

type Image {
  url(size: Int!): URL!
}

type InputValidationError {
  message: String!
}

type InternalContact {
  address: String!
  email: String!
  name: String!
  phone: String!
}

input InternalContactInput {
  address: String
  email: String
  name: String
  phone: String
}

"""Supported languages"""
enum Language {
  CHINESE
  ENGLISH
  FRENCH
  GERMAN
  JAPANESE
  RUSSIAN
  SPANISH
}

type License implements Node {
  description: String!
  id: ID!
  image: Image
  isHidden: Boolean
  notes: String
  permitsSales: Boolean
  summary: String!
  title: String!
}

type LicenseConnection {
  aggregate: Aggregate
  edges: [LicenseEdge!]
  nodes: [License!]
  pageInfo: PageInfo!
}

input LicenseCreateInput {
  description: String
  isHidden: Boolean
  language: Language!
  notes: String
  permitsSales: Boolean
  summary: String
  title: String!
}

type LicenseEdge {
  cursor: String!
  node: License!
}

type LicensePayload {
  errors: [InputValidationError!]!
  license: License
}

input LicensesOrder {
  direction: OrderByDirection!
  field: LicensesSortableField!
}

"""Properties by which license connections can be ordered."""
enum LicensesSortableField {
  CREATED_AT
  ID
  TITLE
}

input LicenseUpdateInput {
  description: String
  isHidden: Boolean
  notes: String
  permitsSales: Boolean
  summary: String
  title: String
}

"""The media file container types."""
enum MediaFileContainer {
  DOC
  DOCX
  FLV
  JPG
  KEY
  M3U8_IOS
  M3U8_WEB
  M4A
  M4V
  MOV
  MP3
  MP4
  ODP
  ODT
  PAGES
  PDF
  PNG
  PPT
  PPTX
  WAV
  WMA
  WMV
}

type Mutation {
  collectionCreate(input: CollectionCreateInput!): CollectionPayload!
  collectionDelete(collectionId: ID!): SuccessPayload!
  collectionUpdate(collectionId: ID!, input: CollectionUpdateInput!): CollectionPayload!
  favoriteRecording(id: ID!): Boolean!
  licenseCreate(input: LicenseCreateInput!): LicensePayload!
  licenseDelete(licenseId: ID!): SuccessPayload!
  licenseUpdate(input: LicenseUpdateInput!, licenseId: ID!): LicensePayload!
  login(input: UserLoginInput!): AuthenticatedUserPayload!
  loginSocial(input: UserLoginSocialInput!): AuthenticatedUserPayload!
  playlistAdd(input: UserPlaylistAddInput!): UserPlaylist!
  playlistDelete(playlistId: ID!): Boolean!
  playlistRecordingAdd(playlistId: ID!, recordingId: ID!): Boolean!
  playlistRecordingRemove(playlistId: ID!, recordingId: ID!): Boolean!
  playlistUpdate(input: UserPlaylistUpdateInput!, playlistId: ID!): UserPlaylist!
  sequenceCreate(input: SequenceCreateInput!): SequencePayload!
  sequenceDelete(sequenceId: ID!): SuccessPayload!
  sequenceUpdate(input: SequenceUpdateInput!, sequenceId: ID!): SequencePayload!
  signup(input: UserSignupInput!): AuthenticatedUserPayload!
  sponsorCreate(input: SponsorCreateInput!): SponsorPayload!
  sponsorDelete(sponsorId: ID!): SuccessPayload!
  sponsorUpdate(input: SponsorUpdateInput!, sponsorId: ID!): SponsorPayload!
  unfavoriteRecording(id: ID!): Boolean!
  updateMyProfile(input: UserUpdateInput!): AuthenticatedUserPayload!
  userCreate(input: UserCreateInput!): UserPayload!
  userDelete(userId: ID!): SuccessPayload!

  """
  Sends a reset password email to the user, as the first step in the reset password process.
  """
  userRecover(
    """The email address of the user to recover."""
    email: String!
  ): SuccessPayload!

  """Resets a user's password with a token received from `userRecover`."""
  userReset(
    """New password that will be set as part of the reset password process."""
    password: String!

    """The reset token required to reset the user's password."""
    token: String!
  ): SuccessPayload!
  userUpdate(input: UserUpdateInput!, userId: ID!): UserPayload!
}

interface Node {
  id: ID!
}

"""
Possible directions in which to order a list of items when provided an `orderBy` argument.
"""
enum OrderByDirection {
  ASC
  DESC
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Person implements Node {
  """The canonical HTML path to this resource."""
  canonicalPath: String!

  """The canonical URL to this resource."""
  canonicalUrl: String!
  description: String!
  givenName: String!
  id: ID!
  image: Image
  imageWithFallback: Image!
  name: String!
  photo: Image @deprecated(reason: "Person.photo is replaced with Person.image")
  photoWithFallback: Image! @deprecated(reason: "Person.photoWithFallback is replaced with Person.imageWithFallback")
  recordings(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [RecordingsOrder!]
    sequenceId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!

  """A shareable short URL to this resource."""
  shareUrl: String!
  summary: String!
  surname: String!
  website: String
}

type PersonConnection {
  aggregate: Aggregate
  edges: [PersonEdge!]
  nodes: [Person!]
  pageInfo: PageInfo!
}

type PersonEdge {
  cursor: String!
  node: Person!
}

input PersonsOrder {
  direction: OrderByDirection!
  field: PersonsSortableField!
}

"""The roles a Person can hold."""
enum PersonsRoleField {
  SPEAKER
  WRITER
}

"""Properties by which person connections can be ordered."""
enum PersonsSortableField {
  CREATED_AT
  ID
  NAME
}

type PopularRecording {
  recording: Recording!
  weight: Float!
}

type PopularRecordingConnection {
  aggregate: Aggregate
  edges: [PopularRecordingEdge!]
  nodes: [PopularRecording!]
  pageInfo: PageInfo!
}

type PopularRecordingEdge {
  cursor: String!
  node: PopularRecording!
}

type Query {
  audiobible(id: ID!): Bible
  audiobibles(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Return the elements that come after the specified offset."""
    offset: Int
  ): BibleConnection!

  """Alias for `sequence(id: ID)`"""
  audiobook(id: ID!): Sequence
  audiobooks(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished sequences. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [SequenceOrder!]
    search: String
    sponsorId: ID
  ): SequenceConnection!

  """Alias for `collection(id: ID)`"""
  audiobookSeries(id: ID!): Collection
  audiobookSerieses(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished collections. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [CollectionsOrder!]
    search: String
    sponsorId: ID
  ): CollectionConnection!

  """Alias for `recording(id: ID)`"""
  audiobookTrack(id: ID!): Recording
  audiobookTracks(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [RecordingsOrder!]
    presenterId: ID

    """
    `search` will find matching recordings and order the recordings by relevance to the search term. Any `orderBy` arguments provided will be ignored.
    """
    search: String
    sequenceId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!
  blogPost(id: ID!): BlogPost
  blogPosts(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [BlogPostOrder!]
  ): BlogPostConnection!
  collection(id: ID!): Collection
  collections(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished collections. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [CollectionsOrder!]
    search: String
    sponsorId: ID
  ): CollectionConnection!

  """Alias for `collection(id: ID)`"""
  conference(id: ID!): Collection
  conferences(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished collections. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [CollectionsOrder!]
    search: String
    sponsorId: ID
  ): CollectionConnection!
  featuredBlogPosts(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
  ): BlogPostConnection!
  featuredRecordings(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID
    contentType: RecordingContentType = SERMON

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    presenterId: ID
    sequenceId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!
  license(id: ID!): License
  licenses(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished licenses. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [LicensesOrder!]
    search: String
  ): LicenseConnection!
  me: AuthenticatedUser

  """Alias for `sequence(id: ID)`"""
  musicAlbum(id: ID!): Sequence
  musicAlbums(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished sequences. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [SequenceOrder!]
    search: String
    sponsorId: ID
  ): SequenceConnection!
  musicBookTags(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
  ): TagConnection! @deprecated(reason: "Query.musicBookTags will be replaced with a scriptural reference type.")
  musicMoodTags(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
  ): TagConnection!

  """Alias for `recording(id: ID)`"""
  musicTrack(id: ID!): Recording
  musicTracks(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [RecordingsOrder!]
    presenterId: ID

    """
    `search` will find matching recordings and order the recordings by relevance to the search term. Any `orderBy` arguments provided will be ignored.
    """
    search: String
    sequenceId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!
  person(id: ID!): Person
  persons(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished persons. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [PersonsOrder!]
    role: PersonsRoleField
    search: String

    """
    Filters persons by those with published recordings of any of the provided content types.
    """
    withContentTypes: [RecordingContentType!]
  ): PersonConnection!
  popularRecordings(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID
    contentType: RecordingContentType = SERMON

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    presenterId: ID
    sequenceId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): PopularRecordingConnection!
  recording(id: ID!): Recording
  recordings(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [RecordingsOrder!]
    presenterId: ID

    """
    `search` will find matching recordings and order the recordings by relevance to the search term. Any `orderBy` arguments provided will be ignored.
    """
    search: String
    sequenceId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!
  sequence(id: ID!): Sequence
  sequences(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished sequences. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [SequenceOrder!]
    search: String
    sponsorId: ID
  ): SequenceConnection!

  """Alias for `sequence(id: ID)`"""
  series(id: ID!): Sequence

  """
  Series is both a singular and plural form. `series` returns a single sequence. `serieses` is an archaic plural form of series used here to avoid `seriess` or some other ugly solution.
  """
  serieses(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished sequences. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [SequenceOrder!]
    search: String
    sponsorId: ID
  ): SequenceConnection!

  """Alias for `recording(id: ID)`"""
  sermon(id: ID!): Recording
  sermons(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [RecordingsOrder!]
    presenterId: ID

    """
    `search` will find matching recordings and order the recordings by relevance to the search term. Any `orderBy` arguments provided will be ignored.
    """
    search: String
    sequenceId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!
  sponsor(id: ID!): Sponsor
  sponsors(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished sponsors. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [SponsorsOrder!]
    search: String
    withMusic: Boolean
  ): SponsorConnection!
  stories(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [RecordingsOrder!]
    presenterId: ID

    """
    `search` will find matching recordings and order the recordings by relevance to the search term. Any `orderBy` arguments provided will be ignored.
    """
    search: String
    sequenceId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!

  """Alias for `recording(id: ID)`"""
  story(id: ID!): Recording

  """Alias for `collection(id: ID)`"""
  storyProgram(id: ID!): Collection
  storyPrograms(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished collections. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [CollectionsOrder!]
    search: String
    sponsorId: ID
  ): CollectionConnection!

  """Alias for `sequence(id: ID)`"""
  storySeason(id: ID!): Sequence
  storySeasons(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished sequences. Requires catalog role."""
    includeUnpublished: Boolean
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [SequenceOrder!]
    search: String
    sponsorId: ID
  ): SequenceConnection!
  testimonies(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [TestimoniesOrder!]
  ): TestimonyConnection!
  user(id: ID!): User
  users(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [UsersOrder!]
    search: String
  ): UserConnection!
}

type Recording implements Node {
  attachments(allowedContainers: [MediaFileContainer!]): [Attachment!]!
  audioFiles(allowedContainers: [MediaFileContainer!], includeUnpublished: Boolean): [AudioFile!]!

  """The canonical HTML path to this resource."""
  canonicalPath: String!
  canonicalUrl: URL!
  collection: Collection
  contentType: RecordingContentType!
  copyrightYear: Int
  description: String
  downloadDisabled: Boolean!
  duration: Float!
  id: ID!
  imageWithFallback: Image!
  persons(includeUnpublished: Boolean, role: PersonsRoleField): [Person!]!
  recordingDate: Date
  recordingTags(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int

    """Return the elements that come after the specified offset."""
    offset: Int
  ): RecordingTagConnection!
  sequence: Sequence
  shareUrl: URL
  sponsor: Sponsor
  title: String!
  transcript: Transcript
  videoFiles(allowedContainers: [MediaFileContainer!], includeUnpublished: Boolean): [VideoFile!]!
  viewerHasFavorited: Boolean!
}

type RecordingConnection {
  aggregate: Aggregate
  edges: [RecordingEdge!]
  nodes: [Recording!]
  pageInfo: PageInfo!
}

"""The available types of recordings."""
enum RecordingContentType {
  AUDIOBOOK_TRACK
  MUSIC_TRACK
  SERMON
  STORY
}

type RecordingEdge {
  cursor: String!
  node: Recording!
}

input RecordingsOrder {
  direction: OrderByDirection!
  field: RecordingsSortableField!
}

"""Properties by which recording connections can be ordered."""
enum RecordingsSortableField {
  CREATED_AT
  ID
  PUBLISHED_AT
  RECORDED_AT
  TITLE
}

type RecordingTag {
  tag: Tag!
}

type RecordingTagConnection {
  aggregate: Aggregate
  edges: [RecordingTagEdge!]
  nodes: [RecordingTag!]
  pageInfo: PageInfo!
}

type RecordingTagEdge {
  cursor: String!
  node: RecordingTag!
}

type Sequence implements Node {
  """The canonical HTML path to this resource."""
  canonicalPath: String!

  """The canonical URL to this resource."""
  canonicalUrl: String!
  collection: Collection
  contentType: SequenceContentType!
  description: String!
  id: ID!
  image: Image
  imageWithFallback: Image!
  isHidden: Boolean
  logoImage: Image @deprecated(reason: "Sequence.logoImage is replaced with Sequence.image")
  logoImageWithFallback: Image! @deprecated(reason: "Sequence.logoImageWithFallback is replaced with Sequence.imageWithFallback")
  notes: String
  recordings(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean

    """Return the elements that come after the specified offset."""
    offset: Int
    presenterId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!

  """A shareable short URL to this resource."""
  shareUrl: String!
  sponsor: Sponsor
  summary: String!
  title: String!
}

type SequenceConnection {
  aggregate: Aggregate
  edges: [SequenceEdge!]
  nodes: [Sequence!]
  pageInfo: PageInfo!
}

"""The available types of sequence."""
enum SequenceContentType {
  AUDIOBOOK
  MUSIC_ALBUM
  SERIES
  STORY_SEASON
}

input SequenceCreateInput {
  collectionId: ID
  contentType: SequenceContentType!
  description: String
  isHidden: Boolean
  notes: String
  sponsorId: ID!
  summary: String
  title: String!
}

type SequenceEdge {
  cursor: String!
  node: Sequence!
}

input SequenceOrder {
  direction: OrderByDirection!
  field: SequenceSortableField!
}

type SequencePayload {
  errors: [InputValidationError!]!
  sequence: Sequence
}

"""Properties by which sequence connections can be ordered."""
enum SequenceSortableField {
  CREATED_AT
  ID
  TITLE
}

input SequenceUpdateInput {
  collectionId: ID
  description: String
  isHidden: Boolean
  notes: String
  sponsorId: ID
  summary: String
  title: String
}

type Sponsor implements Node & UniformResourceLocatable {
  address: String

  """The canonical HTML path to this resource."""
  canonicalPath: String!

  """The canonical URL to this resource."""
  canonicalUrl: String!
  collections(
    """Return the elements that come after the specified cursor."""
    after: String
    contentType: CollectionContentType = CONFERENCE

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished collections. Requires catalog role."""
    includeUnpublished: Boolean

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [CollectionsOrder!]
    search: String
  ): CollectionConnection!
  description: String!
  email: String
  id: ID!
  image: Image
  imageWithFallback: Image!
  internalContact: InternalContact
  isHidden: Boolean!
  location: String
  logoImage: Image @deprecated(reason: "Sponsor.logoImage is replaced with Sponsor.image")
  logoImageWithFallback: Image! @deprecated(reason: "Sponsor.logoImageWithFallback is replaced with Sponsor.imageWithFallback")
  notes: String
  phone: String
  recordings(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID
    contentType: RecordingContentType = SERMON

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [RecordingsOrder!]
    presenterId: ID
    sequenceId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!
  sequences(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID
    contentType: SequenceContentType = SERIES

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished sequences. Requires catalog role."""
    includeUnpublished: Boolean

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [SequenceOrder!]
    search: String
  ): SequenceConnection!

  """A shareable short URL to this resource."""
  shareUrl: String!
  summary: String!
  title: String!
  website: String
}

type SponsorConnection {
  aggregate: Aggregate
  edges: [SponsorEdge!]
  nodes: [Sponsor!]
  pageInfo: PageInfo!
}

input SponsorCreateInput {
  address: String
  description: String
  email: String
  internalContact: InternalContactInput
  isHidden: Boolean
  language: Language!
  location: String
  notes: String
  phone: String
  summary: String
  title: String!
  website: String
}

type SponsorEdge {
  cursor: String!
  node: Sponsor!
}

type SponsorPayload {
  errors: [InputValidationError!]!
  sponsor: Sponsor
}

input SponsorsOrder {
  direction: OrderByDirection!
  field: SponsorsSortableField!
}

"""Properties by which sponsor connections can be ordered."""
enum SponsorsSortableField {
  CREATED_AT
  ID
  TITLE
}

input SponsorUpdateInput {
  address: String
  description: String
  email: String
  internalContact: InternalContactInput
  isHidden: Boolean
  location: String
  notes: String
  phone: String
  summary: String
  title: String
  website: String
}

type SuccessPayload {
  errors: [InputValidationError!]!
  success: Boolean!
}

type Tag implements Node {
  id: ID!
  name: String!
}

type TagConnection {
  aggregate: Aggregate
  edges: [TagEdge!]
  nodes: [Tag!]
  pageInfo: PageInfo!
}

type TagEdge {
  cursor: String!
  node: Tag!
}

input TestimoniesOrder {
  direction: OrderByDirection!
  field: TestimoniesSortableField!
}

"""Properties by which testimony connections can be ordered."""
enum TestimoniesSortableField {
  WRITTEN_DATE
}

type Testimony implements Node {
  author: String!
  body: String!
  id: ID!
  writtenDate: Date!
}

type TestimonyConnection {
  aggregate: Aggregate
  edges: [TestimonyEdge!]
  nodes: [Testimony!]
  pageInfo: PageInfo!
}

type TestimonyEdge {
  cursor: String!
  node: Testimony!
}

type Transcript implements Node {
  id: ID!
  text: String!
}

"""Represents a type that can be retrieved by a URL."""
interface UniformResourceLocatable {
  canonicalPath: String!
  canonicalUrl: String!
  shareUrl: String!
}

"""
A field whose value conforms to the standard URL format as specified in RF3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

type User implements Node {
  """
  The first line of the address. Typically the street address or PO Box number.
  """
  address1: String

  """
  The second line of the address. Typically the number of the apartment, suite, or unit.
  """
  address2: String

  """The name of the city, district, village, or town."""
  city: String

  """The name of the country."""
  country: String
  createdAt: Date!

  """The user's email address."""
  email: String!
  favoriteRecordings(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [RecordingsOrder!]
    presenterId: ID
    sequenceId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!

  """The user's first name."""
  givenName: String!
  id: ID!

  """
  Whether the user has permission to perform all administrative functions.
  """
  isSuperuser: Boolean!

  """The user's preferred interface language."""
  language: Language!

  """
  The full name of the user, based on the values for givenName and surname.
  """
  name: String!
  playlist(id: ID!): UserPlaylist
  playlists(
    """Return the elements that come after the specified cursor."""
    after: String

    """Return up to the first `n` elements from the list."""
    first: Int
    language: Language!

    """Return the elements that come after the specified offset."""
    offset: Int
    orderBy: [UserPlaylistsOrder!]
  ): UserPlaylistConnection!

  """The postal or zip code."""
  postalCode: String

  """The name of the region, such as the province, state, or district."""
  province: String

  """The user's administrative roles."""
  roles: [UserRoles!]!

  """The user's last name."""
  surname: String!
}

type UserConnection {
  aggregate: Aggregate
  edges: [UserEdge!]
  nodes: [User!]
  pageInfo: PageInfo!
}

input UserCreateInput {
  """
  The first line of the address. Typically the street address or PO Box number.
  """
  address1: String

  """
  The second line of the address. Typically the number of the apartment, suite, or unit.
  """
  address2: String

  """The name of the city, district, village, or town."""
  city: String

  """The name of the country."""
  country: String

  """The user's email address."""
  email: String!

  """The user's first name."""
  givenName: String!

  """
  Whether the user has permission to perform all administrative functions.
  """
  isSuperuser: Boolean

  """The user's preferred interface language."""
  language: Language

  """The user's password."""
  password: String

  """The postal or zip code."""
  postalCode: String

  """The name of the region, such as the province, state, or district."""
  province: String

  """The user's administrative roles."""
  roles: [UserRoles!]

  """The user's last name."""
  surname: String!
}

type UserEdge {
  cursor: String!
  node: User!
}

input UserLoginInput {
  email: String!
  password: String!
}

input UserLoginSocialInput {
  givenName: String
  socialId: String!
  socialName: UserSocialServiceName!
  socialToken: String!
  surname: String
}

type UserPayload {
  errors: [InputValidationError!]!
  user: User
}

type UserPlaylist implements Node {
  id: ID!
  isPublic: Boolean!
  language: Language!
  recordings(
    """Return the elements that come after the specified cursor."""
    after: String
    collectionId: ID

    """Return up to the first `n` elements from the list."""
    first: Int

    """Whether to include unpublished recordings. Requires catalog role."""
    includeUnpublished: Boolean

    """Return the elements that come after the specified offset."""
    offset: Int
    presenterId: ID
    sequenceId: ID
    sponsorId: ID

    """The name of the tag to filter the recordings by."""
    tagName: String
  ): RecordingConnection!
  summary: String!
  title: String!
}

input UserPlaylistAddInput {
  isPublic: Boolean!
  language: Language!
  summary: String
  title: String!
}

type UserPlaylistConnection {
  aggregate: Aggregate
  edges: [UserPlaylistEdge!]
  nodes: [UserPlaylist!]
  pageInfo: PageInfo!
}

type UserPlaylistEdge {
  cursor: String!
  node: UserPlaylist!
}

input UserPlaylistsOrder {
  direction: OrderByDirection!
  field: UserPlaylistsSortableField!
}

"""Properties by which a user's playlists connection can be ordered."""
enum UserPlaylistsSortableField {
  CREATED_AT
  ID
  TITLE
}

input UserPlaylistUpdateInput {
  isPublic: Boolean!
  summary: String
  title: String!
}

"""The administrative roles a user may hold."""
enum UserRoles {
  ADMINISTRATION
  CATALOG
  COMMUNCATIONS
  EQUIPMENT
  LEGAL
  MEDIAMANAGER
  SCREENING
  STATS
  TECHNICAL
}

input UserSignupInput {
  email: String!
  password: String!
}

"""The supported social login services."""
enum UserSocialServiceName {
  APPLE
  FACEBOOK
  GOOGLE
}

input UsersOrder {
  direction: OrderByDirection!
  field: UsersSortableField!
}

"""Properties by which user connections can be ordered."""
enum UsersSortableField {
  CREATED_AT
  EMAIL
  ID
}

input UserUpdateInput {
  """
  The first line of the address. Typically the street address or PO Box number.
  """
  address1: String

  """
  The second line of the address. Typically the number of the apartment, suite, or unit.
  """
  address2: String

  """The name of the city, district, village, or town."""
  city: String

  """The name of the country."""
  country: String

  """The user's email address."""
  email: String

  """The user's first name."""
  givenName: String

  """
  Whether the user has permission to perform all administrative functions.
  """
  isSuperuser: Boolean

  """The user's preferred interface language."""
  language: Language

  """The user's password."""
  password: String

  """The postal or zip code."""
  postalCode: String

  """The name of the region, such as the province, state, or district."""
  province: String

  """The user's administrative roles."""
  roles: [UserRoles!]

  """The user's last name."""
  surname: String
}

type VideoFile implements Node {
  bitrate: Int!
  container: String!
  duration: Float!
  filename: String!

  """In bytes"""
  filesize: String!
  height: Int!
  id: ID!

  """The URL to record video views for analytics."""
  logUrl: URL
  mimeType: String!
  recording: Recording!
  url: URL!
  width: Int!
}
